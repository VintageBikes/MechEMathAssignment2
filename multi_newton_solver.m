%Your Implementation of Newton's method
%INPUTS:
%fun: the mathematical function for which we want to compute the root
%   note that the output of fun may include the derivative
%   i.e. [fval,dfdx] = fun(x)
%   or not, i.e. fval = fun(x)
%x_guess the initial guess for Newton's method
%solver_params: a MATLAB struct containing solver settings
%   solver_params.dxmin: terminate early if |x_{i+1}-x_{i}|<dxmin
%   solver_params.ftol: terminate early if |f(x_i)|<ftol
%   solver_params.max_iter: maximum number of iterations allowed
%   solver_params.dxmax: terminate early if |x_{i+1}-x_{i}|>dxmax
%   (meaning that jacobian is probably singular, which is bad)
%   solver_params.numerical_diff: boolean (0 or 1)
%   1-> numerically differentiate, 0-> use analytical derivative
%   should use numerical differentation to compute the Jacobian or
%   use a Jacobian generated by fun. No input assumes numerical by default
%   true->fun is assumed to return [fval,J]
%   false->fun is assumed to only return fval
%OUTPUTS:
%x: the estimate of the root computed by the function
%exit_flag: an integer indicating whether or not the solver succeeded
function [x, exit_flag] = multi_newton_solver(fun,x_guess,solver_params)
    %unpack values from struct (if fields in struct have been set)
    dxmin = 1e-14;
    if isfield(solver_params,'dxmin')
        dxmin = solver_params.dxmin;
    end
    ftol = 1e-14;
    if isfield(solver_params,'ftol')
        ftol = solver_params.ftol;
    end
    max_iter = 200;
    if isfield(solver_params,'max_iter')
        max_iter = solver_params.max_iter;
    end
    dxmax = 1e8;
    if isfield(solver_params,'dxmax')
        dxmax = solver_params.dxmax;
    end
    numerical_diff = 1;
    if isfield(solver_params,'numerical_diff')
        numerical_diff = solver_params.numerical_diff;
    end
    if numerical_diff
        fval = fun(x_guess);
        J = approximate_jacobian(fun, x_guess);
    else
        [fval,J] = fun(x_guess);
    end

    delta_x = 2 * dxmin;
    count = 0;
    while count < max_iter && norm(delta_x) > dxmin && norm(fval) > ftol
        if norm(delta_x) > dxmax
            x = x_guess;
            exit_flag = 1;
            return
        end
        count = count + 1;
        delta_x = J \ -fval;
        x_guess = x_guess + delta_x;
        if numerical_diff
            fval = fun(x_guess);
            J = approximate_jacobian(fun, x_guess);
        else
            [fval, J] = fun(x_guess);
        end
    end
    x = x_guess;
    exit_flag = 0;
end